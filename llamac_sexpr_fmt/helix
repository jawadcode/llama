#![feature(prelude_import)]
#[prelude_import]
use std::prelude::rust_2021::*;
#[macro_use]
extern crate std;
use std::fmt;
pub trait SExpFmt {
    fn sexp_fmt(&self, f: &mut fmt::Formatter<'_>, depth: usize) -> fmt::Result;
}
#[cfg(test)]
mod tests {
    use std::fmt::Display;
    use crate::SExpFmt;
    use llamac_sexpr_fmt_derive::SExpFmt;
    struct Span {
        start: usize,
        end: usize,
    }
    impl Display for Span {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            f.write_fmt(format_args!("span: {0}..{1}", self.start, self.end))
        }
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::derive_tuple_struct"]
    pub const derive_tuple_struct: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("tests::derive_tuple_struct"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            source_file: "llamac_sexpr_fmt/src/lib.rs",
            start_line: 26usize,
            start_col: 8usize,
            end_line: 26usize,
            end_col: 27usize,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::UnitTest,
        },
        testfn: test::StaticTestFn(|| test::assert_test_result(derive_tuple_struct())),
    };
    fn derive_tuple_struct() {
        struct TupleStruct(#[metadata] Span, #[debug] String, #[display] usize);
        impl SExpFmt for TupleStruct {
            fn sexp_fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
                depth: usize,
            ) -> std::fmt::Result {
                use std::fmt::Write;
                f.write_str("(tuple-struct")?;
                f.write_str("    ; ")?;
                (/*ERROR*/)
            }
        }
        impl std::fmt::Display for TupleStruct {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                self.sexp_fmt(f, 0)
            }
        }
        let test = TupleStruct(Span { start: 123, end: 234 }, "testing".to_string(), 2);
        match (
            &test.to_string(),
            &r#"
(tuple-struct    ; span: 123..234
    "testing"
    2)"#.trim_start(),
        ) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        }
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::derive_tuple_struct_nested"]
    pub const derive_tuple_struct_nested: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("tests::derive_tuple_struct_nested"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            source_file: "llamac_sexpr_fmt/src/lib.rs",
            start_line: 50usize,
            start_col: 8usize,
            end_line: 50usize,
            end_col: 34usize,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::UnitTest,
        },
        testfn: test::StaticTestFn(|| test::assert_test_result(
            derive_tuple_struct_nested(),
        )),
    };
    fn derive_tuple_struct_nested() {
        struct TupleStruct1(#[metadata] Span, TupleStruct2, #[display] usize);
        impl SExpFmt for TupleStruct1 {
            fn sexp_fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
                depth: usize,
            ) -> std::fmt::Result {
                use std::fmt::Write;
                f.write_str("(tuple-struct-1")?;
                f.write_str("    ; ")?;
                (/*ERROR*/)
            }
        }
        impl std::fmt::Display for TupleStruct1 {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                self.sexp_fmt(f, 0)
            }
        }
        struct TupleStruct2(#[metadata] Span, #[debug] String, #[display] usize);
        impl SExpFmt for TupleStruct2 {
            fn sexp_fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
                depth: usize,
            ) -> std::fmt::Result {
                use std::fmt::Write;
                f.write_str("(tuple-struct-2")?;
                f.write_str("    ; ")?;
                (/*ERROR*/)
            }
        }
        impl std::fmt::Display for TupleStruct2 {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                self.sexp_fmt(f, 0)
            }
        }
        let test = TupleStruct1(
            Span { start: 123, end: 234 },
            TupleStruct2(Span { start: 345, end: 456 }, "testing".to_string(), 2),
            3,
        );
        match (
            &test.to_string(),
            &r#"
(tuple-struct-1    ; span: 123..234
    (tuple-struct-2    ; span: 345..456
        "testing"
        2)
    3)"#
                .trim_start(),
        ) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        }
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::derive_named_struct"]
    pub const derive_named_struct: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("tests::derive_named_struct"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            source_file: "llamac_sexpr_fmt/src/lib.rs",
            start_line: 86usize,
            start_col: 8usize,
            end_line: 86usize,
            end_col: 27usize,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::UnitTest,
        },
        testfn: test::StaticTestFn(|| test::assert_test_result(derive_named_struct())),
    };
    fn derive_named_struct() {
        struct NamedStruct {
            #[metadata]
            span: Span,
            #[debug]
            first: String,
            #[display]
            second: usize,
        }
        impl SExpFmt for NamedStruct {
            fn sexp_fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
                depth: usize,
            ) -> std::fmt::Result {
                use std::fmt::Write;
                f.write_str("(named-struct")?;
                f.write_str("    ; ")?;
                (/*ERROR*/)
            }
        }
        impl std::fmt::Display for NamedStruct {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                self.sexp_fmt(f, 0)
            }
        }
        let test = NamedStruct {
            span: Span { start: 123, end: 234 },
            first: "testing".to_string(),
            second: 2,
        };
        match (
            &test.to_string(),
            &r#"
(named-struct    ; span: 123..234
    :first "testing"
    :second 2)"#
                .trim_start(),
        ) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        }
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::derive_named_struct_nested"]
    pub const derive_named_struct_nested: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("tests::derive_named_struct_nested"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            source_file: "llamac_sexpr_fmt/src/lib.rs",
            start_line: 117usize,
            start_col: 8usize,
            end_line: 117usize,
            end_col: 34usize,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::UnitTest,
        },
        testfn: test::StaticTestFn(|| test::assert_test_result(
            derive_named_struct_nested(),
        )),
    };
    fn derive_named_struct_nested() {
        struct NamedStruct1 {
            #[metadata]
            span: Span,
            first: NamedStruct2,
            #[display]
            second: usize,
        }
        impl SExpFmt for NamedStruct1 {
            fn sexp_fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
                depth: usize,
            ) -> std::fmt::Result {
                use std::fmt::Write;
                f.write_str("(named-struct-1")?;
                f.write_str("    ; ")?;
                (/*ERROR*/)
            }
        }
        impl std::fmt::Display for NamedStruct1 {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                self.sexp_fmt(f, 0)
            }
        }
        struct NamedStruct2 {
            #[metadata]
            span: Span,
            #[debug]
            first: String,
            #[display]
            second: usize,
        }
        impl SExpFmt for NamedStruct2 {
            fn sexp_fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
                depth: usize,
            ) -> std::fmt::Result {
                use std::fmt::Write;
                f.write_str("(named-struct-2")?;
                f.write_str("    ; ")?;
                (/*ERROR*/)
            }
        }
        impl std::fmt::Display for NamedStruct2 {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                self.sexp_fmt(f, 0)
            }
        }
        let test = NamedStruct1 {
            span: Span { start: 123, end: 234 },
            first: NamedStruct2 {
                span: Span { start: 345, end: 456 },
                first: "testing".to_string(),
                second: 2,
            },
            second: 3,
        };
        match (
            &test.to_string(),
            &r#"
(named-struct-1    ; span: 123..234
    :first
        (named-struct-2    ; span: 345..456
            :first "testing"
            :second 2)
    :second 3)"#
                .trim_start(),
        ) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        }
    }
    extern crate test;
    #[cfg(test)]
    #[rustc_test_marker = "tests::derive_enum_units"]
    pub const derive_enum_units: test::TestDescAndFn = test::TestDescAndFn {
        desc: test::TestDesc {
            name: test::StaticTestName("tests::derive_enum_units"),
            ignore: false,
            ignore_message: ::core::option::Option::None,
            source_file: "llamac_sexpr_fmt/src/lib.rs",
            start_line: 167usize,
            start_col: 8usize,
            end_line: 167usize,
            end_col: 25usize,
            compile_fail: false,
            no_run: false,
            should_panic: test::ShouldPanic::No,
            test_type: test::TestType::UnitTest,
        },
        testfn: test::StaticTestFn(|| test::assert_test_result(derive_enum_units())),
    };
    fn derive_enum_units() {
        enum EnumOfUnits {
            First,
            Second,
            Third,
        }
        impl SExpFmt for EnumOfUnits {
            fn sexp_fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
                depth: usize,
            ) -> std::fmt::Result {
                use std::fmt::Write;
                match self {
                    Self::First => {
                        f.write_str("enum-of-units::first")?;
                    }
                    Self::Second => {
                        f.write_str("enum-of-units::second")?;
                    }
                    Self::Third => {
                        f.write_str("enum-of-units::third")?;
                    }
                };
                Ok(())
            }
        }
        impl std::fmt::Display for EnumOfUnits {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                self.sexp_fmt(f, 0)
            }
        }
        let test1 = EnumOfUnits::First;
        match (&test1.to_string(), &r"
enum-of-units::first".trim_start()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        let test2 = EnumOfUnits::Second;
        match (&test2.to_string(), &r"
enum-of-units::second".trim_start()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        };
        let test3 = EnumOfUnits::Third;
        match (&test3.to_string(), &r"
enum-of-units::third".trim_start()) {
            (left_val, right_val) => {
                if !(*left_val == *right_val) {
                    let kind = ::core::panicking::AssertKind::Eq;
                    ::core::panicking::assert_failed(
                        kind,
                        &*left_val,
                        &*right_val,
                        ::core::option::Option::None,
                    );
                }
            }
        }
    }
}
#[rustc_main]
#[no_coverage]
pub fn main() -> () {
    extern crate test;
    test::test_main_static(
        &[
            &derive_enum_units,
            &derive_named_struct,
            &derive_named_struct_nested,
            &derive_tuple_struct,
            &derive_tuple_struct_nested,
        ],
    )
}
